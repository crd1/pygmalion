package net.rudoll.pygmalion.handlers.openapi.export

import io.swagger.v3.oas.models.OpenAPI
import io.swagger.v3.oas.models.Operation
import io.swagger.v3.oas.models.PathItem
import io.swagger.v3.oas.models.info.Info
import io.swagger.v3.oas.models.responses.ApiResponse
import io.swagger.v3.oas.models.responses.ApiResponses
import net.rudoll.pygmalion.model.StateHolder

object OpenApiMonitor {

    fun add(method: String, route: String) {
        val paths = StateHolder.state.openAPISpec.paths
        if (paths == null || paths[route] == null) {
            StateHolder.state.openAPISpec.path(route, PathItem())
        }
        addMethod(StateHolder.state.openAPISpec.paths[route]!!, method)
    }

    private fun addMethod(pathItem: PathItem, method: String) {
        when (method.toLowerCase()) {
            "get" -> pathItem.get(getOperation())
            "post" -> pathItem.post(getOperation())
            "put" -> pathItem.put(getOperation())
            "delete" -> pathItem.delete(getOperation())
            "options" -> pathItem.options(getOperation())
        }
    }

    private fun getOperation(): Operation {
        val operation = Operation()
        operation.responses(ApiResponses().addApiResponse("200", ApiResponse().description("OK")))
        return operation
    }

    fun getPrototype(): OpenAPI {
        val openApi = OpenAPI()
        openApi.info(getInfo())
        return openApi
    }

    private fun getInfo(): Info {
        val info = Info()
        info.version = "1.0"
        info.title = "Demo API"
        info.description = "Generated by Pygmalion"
        return info
    }
}